<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Functional Programming in Rust 1: Closures - Madhav Khosla</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="What is Functional Programming ? It is a Programming Paradigm where you use functions to solve what you are building. Most common features that you might have used FP in any language will be Map and Reduce. Where you pass in a function what iterates in the collection you run map or reduce on.
Rust has some functional features too that I plan to write here.
Closures Let&rsquo;s do a quick Google search &ldquo;closures&rdquo;; The first result that comes to me is from MDN."><meta property="og:image" content><meta property="og:title" content="Functional Programming in Rust 1: Closures"><meta property="og:description" content="What is Functional Programming ? It is a Programming Paradigm where you use functions to solve what you are building. Most common features that you might have used FP in any language will be Map and Reduce. Where you pass in a function what iterates in the collection you run map or reduce on.
Rust has some functional features too that I plan to write here.
Closures Let&rsquo;s do a quick Google search &ldquo;closures&rdquo;; The first result that comes to me is from MDN."><meta property="og:type" content="article"><meta property="og:url" content="https://madhavkhoslaa.github.io/draft/functionalrust/"><meta property="article:section" content="draft"><meta property="article:published_time" content="2022-09-14T02:01:58+05:30"><meta property="article:modified_time" content="2022-09-14T02:01:58+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Functional Programming in Rust 1: Closures"><meta name=twitter:description content="What is Functional Programming ? It is a Programming Paradigm where you use functions to solve what you are building. Most common features that you might have used FP in any language will be Map and Reduce. Where you pass in a function what iterates in the collection you run map or reduce on.
Rust has some functional features too that I plan to write here.
Closures Let&rsquo;s do a quick Google search &ldquo;closures&rdquo;; The first result that comes to me is from MDN."><script src=https://madhavkhoslaa.github.io/js/feather.min.js></script>
<link href=https://madhavkhoslaa.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://madhavkhoslaa.github.io/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://madhavkhoslaa.github.io/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css></head><body><div class=content><header><div class=main><a href=https://madhavkhoslaa.github.io/>Madhav Khosla</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/draft>Draft</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>Functional Programming in Rust 1: Closures</h1><div class=meta>Posted on Sep 14, 2022</div></div><section class=body><p><img src=https://i.imgur.com/y0nqC0G.jpg alt=image></p><h1 id=what-is-functional-programming->What is Functional Programming ?</h1><p>It is a Programming Paradigm where you use functions to solve what you are building. Most common features that you might have used FP in any language will be Map and Reduce.
Where you pass in a function what iterates in the collection you run map or reduce on.</p><p>Rust has some functional features too that I plan to write here.</p><h1 id=closures>Closures</h1><p>Let&rsquo;s do a quick Google search &ldquo;closures&rdquo;; The first result that comes to me is from MDN.</p><p>Let&rsquo;s see what MDN has to say(even though it is JS).</p><p><code>A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function's scope from an inner function.</code></p><h2 id=what-information-can-we-take-from-this-statement>What information can we take from this statement?</h2><ol><li>It is a function that is inside a function</li><li>The inner function shares the same enviorment as the outer function.</li></ol><h2 id=what-information-we-can-conclude-from-this-statement->What information we can conclude from this statement ?</h2><ol><li>The variables defined in the outer function are accessable in the inner function.</li></ol><p>There is alot of information that is left here in context of rust, but hold on for a while :D</p><h1 id=syntax-for-closure-in-rust>Syntax for closure in Rust.</h1><p>Take a look carefully on how you can create closures in rust.</p><ol><li>You give no typpe signatures for the formal arguments.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>arg<span style=color:#f92672>|</span> arg <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><ol start=2><li>You give no return type signatures for the closure.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>arg: <span style=color:#66d9ef>u8</span><span style=color:#f92672>|</span> arg <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><ol start=3><li>You give types for the formal arguments and the return signatures.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>arg: <span style=color:#66d9ef>u8</span><span style=color:#f92672>|</span> -&gt; <span style=color:#66d9ef>u8</span> {arg <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>} 
</span></span></code></pre></div><p>So closures in rust are kind of &ldquo;Pythonic&rdquo; in a way where you can choose to give function type signatures, Right ? Yes, but to an extent. Look at this example</p><h2 id=playing-with-closures->Playing with Closures !!!!</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> example <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>arg<span style=color:#f92672>|</span> arg <span style=color:#f92672>+</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//  ^ This closure has no types for the arg, it just adds 10 to any type that supports addition(We can assume the minimum requirment of the type here)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> x: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>11</span>;
</span></span><span style=display:flex><span>    example(x);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Called with type &#34;usize&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    example(y);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Called with type &#34;u8&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>You might expect this program to compile correctly and on runtime to print 21 and 21.</p><p>But we recieve a compile error.</p><p>Output</p><pre tabindex=0><code>error[E0308]: mismatched types
  --&gt; src/main.rs:10:13
   |
10 |     example(y);
   |     ------- ^ expected `usize`, found `u8`
   |     |
   |     arguments to this function are incorrect
   |
note: closure defined here
  --&gt; src/main.rs:6:19
   |
6  |     let example = |arg| arg + 10;
   |                   ^^^^^
help: you can convert a `u8` to a `usize`
   |
10 |     example(y.into());
   |              +++++++

For more information about this error, try `rustc --explain E0308`.
error: could not compile `playground` due to previous error
</code></pre><p>When we disect the error(Rust has best errors btw) we see that on the second time the compiler says that &ldquo;expected <code>usize</code> found <code>u8</code>&rdquo; and then gives a suggestion.</p><p>So we learn that a closure takes the first arguments type and return type as the type signature of the closure.</p><h2 id=playing-with-closuresagain>Playing with closures(again)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// defined in function main
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>c: <span style=color:#66d9ef>u8</span><span style=color:#f92672>|</span> -&gt; <span style=color:#66d9ef>u8</span> {c <span style=color:#f92672>+</span> b};
</span></span><span style=display:flex><span>    <span style=color:#75715e>// closure a uses b to add to the argument
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> z <span style=color:#f92672>=</span> a(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Result is assigned to z.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>,z);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Output</p><pre tabindex=0><code>2
</code></pre><p>We cacn observe here that variable b is accessable inside of closure a, so we can conclude that a closure shares the same scope as the parent.</p><h2 id=phew-alot-of-stuff-to-learn-lets-break-down-what-i-wrote-down>Phew, alot of stuff to learn. Let&rsquo;s break down what I wrote down</h2><ol><li>Closures are funtions that are inside a function and hence share the same scope as the parent function.</li><li>The are &ldquo;Pythonic&rdquo; in a way that they do not need type signatures but instead the compiler gives it a signature based off the type of arguments on the first call.</li></ol><h1 id=moving-values-inside-closures>Moving values inside closures.</h1><p>If you&rsquo;re reading this blog I expect you to know what a move in rust is. If you don&rsquo;t you can read <a href=https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html>this</a>.</p><p>So there are three ways of moving values into closues.</p><ol><li>Immutable immutable</li><li>Mutable argument</li><li>Borrowing</li></ol><h2 id=example-of-immutable-arguments>Example of Immutable arguments</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> list <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> only_borrows <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>list<span style=color:#f92672>|</span> println!(<span style=color:#e6db74>&#34;From closure: {:?}&#34;</span>, list);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Before calling closure: {:?}&#34;</span>, list);
</span></span><span style=display:flex><span>    only_borrows(list);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;After calling closure: {:?}&#34;</span>, list);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Output</p><pre tabindex=0><code>   Compiling playground v0.0.1 (/playground)
error[E0382]: borrow of moved value: `list`
 --&gt; src/main.rs:8:45
  |
2 |     let list = vec![1, 2, 3];
  |         ---- move occurs because `list` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
...
7 |     only_borrows(list);
  |                  ---- value moved here
8 |     println!(&#34;After calling closure: {:?}&#34;, list);
  |                                             ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `playground` due to previous error
</code></pre><h3 id=explaination>Explaination</h3><hr><h2 id=example-of-mutable-arguments>Example of Mutable arguments</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> list <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> only_borrows <span style=color:#f92672>=</span> <span style=color:#f92672>|</span><span style=color:#66d9ef>mut</span> list: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;|</span> {
</span></span><span style=display:flex><span>    list.push(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;From closure: {:?}&#34;</span>, list );
</span></span><span style=display:flex><span>    list
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Before calling closure: {:?}&#34;</span>, list);
</span></span><span style=display:flex><span>    list <span style=color:#f92672>=</span> only_borrows(list);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;After calling closure: {:?}&#34;</span>, list);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Output</p><pre tabindex=0><code>Before calling closure: [1, 2, 3]
From closure: [1, 2, 3, 4]
After calling closure: [1, 2, 3, 4]
</code></pre><h3 id=explaination-1>Explaination</h3><hr><h2 id=example-of-borowing>Example of borowing</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> list: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> only_borrows <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>list: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;|</span> {
</span></span><span style=display:flex><span>    list.push(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;From closure: {:?}&#34;</span>, list );
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Before calling closure: {:?}&#34;</span>, list);
</span></span><span style=display:flex><span>    only_borrows(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> list);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;After calling closure: {:?}&#34;</span>, list);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Output</p><pre tabindex=0><code>Before calling closure: [1, 2, 3]
From closure: [1, 2, 3, 4]
After calling closure: [1, 2, 3, 4]
</code></pre><h3 id=explaination-2>Explaination</h3><hr><h1 id=moving-capured-values-out-of-fn-traits>Moving capured values out of fn traits</h1><p>So, once a value or a refrence has been passed to the closure, The closure decides what happens with it.
It could use the value once and drop it, mutate the value or can take refrences to a value and do all of these.</p><p>Why do we have to do this ?
Since Rust has this philosophy of all errors being compile time errors and not runtime errors, we need to know how the values are being handled inside the closure so that in the runtime we do not get any UBs.</p><p>This defines three types of closures traits when they are passes in functions or in structs.</p><ol><li><code>FnOnce</code> -> Uses the value which is passed in it and drops it</li><li><code>FnMut</code> -> It can modify the passed values</li><li><code>Fn</code> -> Can take any refrence</li></ol><h2 id=example-of-fnonce>Example of <code>FnOnce</code></h2><h2 id=example-of-fnmut>Example of <code>FnMut</code></h2><h2 id=example-of-fn>Example of <code>Fn</code></h2></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/rust>Rust</a></li><li><a href=/tags/c++>C++</a></li><li><a href=/tags/functional-programming>Functional Programming</a></li><li><a href=/tags/closures>Closures</a></li><li><a href=/tags/traits>Traits</a></li><li><a href=/tags/ferris>Ferris</a></li><li><a href=/tags/blazingly-fast>Blazingly Fast</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://bit.ly/3Qyr87Y title=GitHub><i data-feather=github></i></a><a class=soc href=https://bit.ly/3Qtgn6y title=Twitter><i data-feather=twitter></i></a></div><div class=footer-info>2022 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>