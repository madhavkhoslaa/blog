<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Understanding Rust Ownership - Madhav Khosla</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Ownership is one of the features that make it different than so many programming languages and what makes it memory safe and a good language for concurrent programming. It solves problems like null pointers, dangling pointers and data races."><meta property="og:image" content><meta property="og:title" content="Understanding Rust Ownership"><meta property="og:description" content="Ownership is one of the features that make it different than so many programming languages and what makes it memory safe and a good language for concurrent programming. It solves problems like null pointers, dangling pointers and data races."><meta property="og:type" content="article"><meta property="og:url" content="https://madhavkhoslaa.github.io/posts/rustownership/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-03T02:01:58+05:30"><meta property="article:modified_time" content="2022-07-03T02:01:58+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding Rust Ownership"><meta name=twitter:description content="Ownership is one of the features that make it different than so many programming languages and what makes it memory safe and a good language for concurrent programming. It solves problems like null pointers, dangling pointers and data races."><script src=https://madhavkhoslaa.github.io/js/feather.min.js></script><link href=https://madhavkhoslaa.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://madhavkhoslaa.github.io/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://madhavkhoslaa.github.io/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css></head><body><div class=content><header><div class=main><a href=https://madhavkhoslaa.github.io/>Madhav Khosla</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/draft>Draft</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>Understanding Rust Ownership</h1><div class=meta>Posted on Jul 3, 2022</div></div><section class=body><p>Ownership is one of the features that make it different than so many programming languages and what makes it memory safe and a good language for concurrent programming. It solves problems like null pointers, dangling pointers and data races without a garbage collector at the run time.</p><h1 id=understanding-rust-ownership>Understanding Rust Ownership</h1><p><img src=https://i.imgur.com/j5Pxkuu.jpg alt=image></p><h1 id=how-is-data-stored-in-the-program>How is data stored in the program?</h1><ol><li>Stack</li><li>Heap</li></ol><p>Data(variables in function arguments and defined) in the stack have a known type hence the size of the data in the stack is known at the time of compilation. However, data types like vectors and strings are bound to grow in size hence they are stored in the heap(their size cannot be determined at the time of compilation).</p><p><img src=https://i.imgur.com/jiQn04E.png alt=image>
The image above shows the organization of a stack.</p><h1 id=what-is-ownership>What is ownership?</h1><p>Rust aims to solve problems like dangling pointers in languages like C++(<a href="https://www.youtube.com/watch?v=Nq5ZbOOJGwg">CPP Slander</a>).</p><p>Problem 1</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>Node<span style=color:#f92672>*</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node();
</span></span><span style=display:flex><span>some_funtion(a);
</span></span><span style=display:flex><span><span style=color:#f92672>*</span>a<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node()
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> some_funtion(Node<span style=color:#f92672>*</span> node){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> a;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Problem 2</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>some_function(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>100</span>; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> n <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Problems like these in rust are rare and you know when you are making those.</p><p>Ownership is how rust compiler managers data in the heap safely without a garbage collector at the compile time.</p><h1 id=rules-of-ownership>Rules of ownership</h1><ol><li>Each value in Rust has an owner.</li><li>There can only be one owner at a time.</li><li>When the owner goes out of scope, the value will be dropped.</li></ol><p>Source: <a href=https://doc.rust-lang.org/book/title-page.html>Rust Lang Book</a></p><h2 id=what-is-value>What is value?</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello World&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>//  ^ Owner ^Value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h1 id=understanding-ownership-through-real-life-examples>Understanding ownership through real-life examples</h1><h2 id=scenario-1>Scenario 1</h2><ol><li>Assume you have a laptop.</li><li>Your friend wants to borrow your laptop</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> madhav <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Madhav&#39;s Laptop&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Madhav is the owner and he owns the string &#34;Madhav&#39;s Laptop&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> diya <span style=color:#f92672>=</span> madhav;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Diya = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, Madhav = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, madhav, diya);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>relating to other languages like c++, you might expect that variable named <code>diya</code> will have the value of the string, and the variable <code>madhav</code> will have it too? However, the output says something different.
Output:</p><pre tabindex=0><code>error[E0382]: borrow of moved value: `madhav`
 --&gt; src/main.rs:5:40
  |
2 |     let madhav = String::from(&#34;Madhav&#39;s Laptop&#34;);
  |         ------ move occurs because `madhav` has type `String`, which does not implement the `Copy` trait
3 |     // Madhav is the owner and he owns the value &#34;Madhav&#39;s Laptop&#34;;
4 |     let diya = madhav;
  |                ------ value moved here
5 |     println!(&#34;Diya = {}, Madhav = {}&#34;, madhav, diya);
  |                                        ^^^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
</code></pre><p>Just like in reality if madhav gives his laptop to diya he will not have the laptop while the laptop is with diya, right?</p><h3 id=explaination>Explaination</h3><p>(Read #Rules of ownership 1. and 2.). These rules state that for a value there can be only one owner. In the case above there were two owners at the same time. And we got an error saying <code>borrow of moved value: madhav</code> when we tried printing the value of the variable <code>madhav</code>.</p><h4 id=so-what-is-a-move-in-rust>So what is a move in rust?</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Some string&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> a; <span style=color:#75715e>// This is a move
</span></span></span></code></pre></div><p>in other languages, b might copy the value of a or point to the same location as a. but in rust, there can be only one owner to a value as we studied above. So what happens is b takes the ownership of the value that a point towards.</p><h4 id=how-does-diya-gets-madhavs-laptop>How does diya gets madhav&rsquo;s laptop?</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> madhav <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Madhav&#39;s Laptop&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Madhav is the owner and he owns the string &#34;Madhav&#39;s Laptop&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> diya <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>madhav;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Diya = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, Madhav = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, madhav, diya);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here the variable <code>diya</code> borrows the value from the variable <code>madhav</code>.</p><p>Output</p><pre tabindex=0><code>Diya = Madhav&#39;s Laptop, Madhav = Madhav&#39;s Laptop
</code></pre><h2 id=scenario-2>Scenario 2</h2><ol><li>Assume you have a Laptop and you need to overclock it.</li><li>Your friend <code>borrows</code> your laptop and overclocks it.</li><li>Friend returns the laptop to you</li></ol><p><code>madhav</code> variables pass his laptop to the function <code>overclock_laptop()</code> and expects laptop string to be appended with &ldquo;+ 2Ghz&rdquo; but what does happen?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> madhav <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Madhav&#39;s Laptop&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Madhav is the owner and he owns the string &#34;Madhav&#39;s Laptop&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> madhav <span style=color:#f92672>=</span> overclock_laptop(madhav);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, madhav)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>overclock_laptop</span>(<span style=color:#66d9ef>mut</span> laptop: String) -&gt; String {
</span></span><span style=display:flex><span>    laptop.push_str(<span style=color:#e6db74>&#34; + 2Ghz&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> laptop;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>output</p><pre tabindex=0><code>Madhav&#39;s Laptop + 2Ghz
</code></pre><p>This code works fine, but there&rsquo;s a tiny inconvenience here. The inconvenience is that we have to pass around ownership from functions to variables again and again at our point you will have to return tuples and it can get messy.</p><h3 id=borrowing-in-function>Borrowing in function</h3><p>Here we create a mutable variable <code>madhav</code> we pass in the mutable reference to the function <code>overclock_laptop</code>, where the variable is mutated, Notice here we did not have to switch ownership multiple times, since the function borrowed the value once and it got reflected in the variable in the function main.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> madhav <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Madhav&#39;s Laptop&#34;</span>);
</span></span><span style=display:flex><span>    overclock_laptop(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> madhav);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, madhav);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>overclock_laptop</span>(laptop: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> String) {
</span></span><span style=display:flex><span>    laptop.push_str(<span style=color:#e6db74>&#34;+ 2Ghz&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Output:</p><pre tabindex=0><code>Madhav&#39;s Laptop + 2Ghz
</code></pre><h1 id=what-is-stored-in-the-heap>What is stored in the heap?</h1><ol><li>String</li><li>Vector</li><li>Structs - A <code>struct</code> could have alot of fields and making a decision to copy the values would be cost inefficient and a borrowed reference will be better..</li></ol><hr></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/rust>Rust</a></li><li><a href=/tags/ownership>Ownership</a></li><li><a href=/tags/not-c++>Not C++</a></li><li><a href=/tags/blazingly-fast>Blazingly Fast</a></li><li><a href=/tags/ferris>Ferris</a></li><li><a href=/tags/borrowing>Borrowing</a></li><li><a href=/tags/heap>heap</a></li><li><a href=/tags/stack>stack</a></li><li><a href=/tags/pointers>pointers</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://bit.ly/3Qyr87Y title=GitHub><i data-feather=github></i></a><a class=soc href=https://bit.ly/3Qtgn6y title=Twitter><i data-feather=twitter></i></a></div><div class=footer-info>2023 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>