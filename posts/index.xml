<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Madhav Khosla</title><link>https://madhavkhoslaa.github.io/posts/</link><description>Recent content in Posts on Madhav Khosla</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 08 Jun 2023 02:01:58 +0530</lastBuildDate><atom:link href="https://madhavkhoslaa.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Error handling in Rust.</title><link>https://madhavkhoslaa.github.io/posts/errors/</link><pubDate>Thu, 08 Jun 2023 02:01:58 +0530</pubDate><guid>https://madhavkhoslaa.github.io/posts/errors/</guid><description>Types of Errors Unrecoverable Errors Recoverable Errors How to handle unrecoverable Errors. These errors are errors that make you want to stop the execution of the program. Like not being able to find a free port for starting the server, division by zero. These errors use the panic macro to stop the execution of the program in rust.
Example of panic macro. fn main(){ let a = 5; let b = 0; let c = divide(a, b); println!</description></item><item><title>Functional Programming in Rust 2: Iterators</title><link>https://madhavkhoslaa.github.io/posts/rustiter/</link><pubDate>Sun, 20 Nov 2022 23:01:35 +0530</pubDate><guid>https://madhavkhoslaa.github.io/posts/rustiter/</guid><description>Iterator Design Pattern, What is it? Example 1 Let&amp;rsquo;s consider you are this tiny person in the image and you have to walk traverse the tree below. Ideally, how you traverse it, it does not matter what is the most important thing is 1. where you are and 2. Where you want to be when you go to the next node.
So in a way, an iterator design pattern(in real life) is a thought process of how you iterate a structure(not just a tree), or you know where you want(not how) to go next.</description></item><item><title>Functional Programming in Rust 1: Closures</title><link>https://madhavkhoslaa.github.io/posts/functionalrust/</link><pubDate>Tue, 27 Sep 2022 02:01:58 +0530</pubDate><guid>https://madhavkhoslaa.github.io/posts/functionalrust/</guid><description>What is Functional Programming? It is a Programming Paradigm where you use functions to solve what you are building. The most common features that you might have used FP in any language will be Map and Reduce. Where you pass in a function what iterates in the collection you run map or reduce on.
Rust has some functional features too that I plan to write here.
Closures Let&amp;rsquo;s do a quick Google search &amp;ldquo;closures&amp;rdquo;; The first result that comes to me is from MDN.</description></item><item><title>Understanding Rust Ownership</title><link>https://madhavkhoslaa.github.io/posts/rustownership/</link><pubDate>Sun, 03 Jul 2022 02:01:58 +0530</pubDate><guid>https://madhavkhoslaa.github.io/posts/rustownership/</guid><description>Ownership is one of the features that make it different than so many programming languages and what makes it memory safe and a good language for concurrent programming. It solves problems like null pointers, dangling pointers and data races without a garbage collector at the run time.
Understanding Rust Ownership How is data stored in the program? Stack Heap Data(variables in function arguments and defined) in the stack have a known type hence the size of the data in the stack is known at the time of compilation.</description></item><item><title>Creational Design Patterns: My lessons on it</title><link>https://madhavkhoslaa.github.io/posts/ceationaldesignpatterns/</link><pubDate>Fri, 24 Jun 2022 02:01:58 +0530</pubDate><guid>https://madhavkhoslaa.github.io/posts/ceationaldesignpatterns/</guid><description>Creational Design Patterns Creational design patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.
Why were they made and why should you care about reading them? You must have noticed in a larger code base where multiple classes dealing with the class instantiation becomes too hard, in fact in the case of languages like java where the ecosystem expects everything to be a class; a framework called spring had been developed to solve the problem of instantiating classes(and so much more).</description></item><item><title>SOLID Patterns: My lessons on it</title><link>https://madhavkhoslaa.github.io/posts/solid/</link><pubDate>Tue, 07 Jun 2022 04:01:25 +0530</pubDate><guid>https://madhavkhoslaa.github.io/posts/solid/</guid><description>SOLID is just an acronym for a few principles that Robert C. Martin compiled together. SOLID Design principles aim to make your code base extensible, easy to modify in the future, and easy to debug and fix. They are not rules just a bunch of thought ideas of segregation of logic and how to organize your code.
S =&amp;gt; Single Responsibility Principle
O =&amp;gt; Open Close Princple
L =&amp;gt; Liskov Substitution Principle</description></item><item><title>Caching: My lessons on it</title><link>https://madhavkhoslaa.github.io/posts/post1/</link><pubDate>Sat, 19 Mar 2022 02:01:58 +0530</pubDate><guid>https://madhavkhoslaa.github.io/posts/post1/</guid><description>Caching is a cheap way to scale a system&amp;rsquo;s performance in very less time. Being cheap and easy to implement on the top of a existing system it also brings some problems such as invalidation and infrastructure for setting up the cache itself. Here I plan to talk about some lessons on caching that I&amp;rsquo;ve learnt in a few months.
Philosophy of Caching The supreme art of war is to subdue the enemy without fighting it - Sun Tzu</description></item></channel></rss>